---
title: "Package Interconnection"
author: "Dewi Lestari Amaliah"
date: "03/09/2021"
output: bookdown::html_document2
bibliography: paper.bib
---

```{r setup-section4, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(yaml)
library(reshape)
library(tidyverse)
library(lubridate)
library(splitstackshape)
library(igraph)
library(tidygraph)
library(ggraph)
library(networkD3)
library(visNetwork)
library(qdapRegex)
```

# Interaction

```{r network-data}
pkg_df <- yaml.load_file(here::here("data/input/doe-pkgs.yml")) %>%
  melt()

#tidy the data frame
pkg_tidy <- pkg_df %>%
  pivot_wider(names_from = L3,
              values_from = value)

# make list of doe package 
list_pkg <- as.list(pkg_tidy)$L2

# create function to extract the depends, imports, and suggests 
get_pkg <- function(var){
  # select only the package name and depends/imports/suggests
  tmp_df <- pkg_tidy %>%
    select(L2, author, var) %>%
    # separate every depends/imports/suggests
    cSplit(var, sep = " ,") 
  
  df <- tmp_df %>%
    pivot_longer(c(3:ncol(tmp_df)), names_to = "type", values_to = "pkg") %>%
    filter(!is.na(pkg)) %>%
    # check if the depends/imports/suggests is also a DoE package (is in list_pkg)
    mutate(doe_pkg_related = ifelse(pkg %in% list_pkg, "yes", "no")) %>%
    # filter only package whose depends/imports/suggests is a DoE
    filter(doe_pkg_related == "yes") %>%
    # tidy the data to only have the type: depends/imports/suggests
    cSplit("type", sep = "_") %>%
    select(-type_2) %>%
    rename(type = type_1)

  return(df)
}

# create data frame from the above function
depend_df <- get_pkg("depends")
import_df <- get_pkg("imports")
suggest_df <- get_pkg("suggests")

# bind data frames
pkg_edges <- rbind(depend_df, import_df, suggest_df) %>%
  select(-doe_pkg_related) %>%
  select(pkg, L2, type, author)
  

# extract unique package that has depends/imports/suggests
from <- pkg_edges %>%
  distinct(L2)

# extract unique package that being depends/imports/suggests
to <- pkg_edges %>%
  distinct(pkg)

# create nodes from the two previous dataframe
pkg_nodes_tmp <- full_join(from, to, by = c("L2" = "pkg")) %>%
  left_join(pkg_tidy, by = "L2") %>%
  select(L2, author)

### get author and count how many packages they write as the first author
### there are many authors who wrote >1 packages but in the same packages, here, we just extract the first author
```


```{r network-data-aut}

## separate author 
aut_tidy <- pkg_nodes_tmp %>%
  # separate each aut/ctb/cph for each package
  separate_rows(author, sep=", (?=[A-Z])") %>%
  # filter only role aut and filter out cph
  filter(!str_detect(author, "ctb") & !str_detect(author, "National") & !str_detect(author, "Columbia")) 

# replace character inside angle and square bracket
aut_tidy$author <- rm_angle(aut_tidy$author, replacement = "")
aut_tidy$author <- rm_square(aut_tidy$author, replacement = "")

# remove contributors written as sentence
aut_tidy <- aut_tidy %>%
  mutate(author = ifelse(str_detect(author, "Contributor"), "Yves Deville",
                         ifelse(str_detect(author, "based"), "Ernesto Barrios",
                                ifelse(str_detect(author, "contributions"), "John Lawson", author))))

# extract author who wrote >1 packages
aut_group <- aut_tidy %>%
  group_by(author) %>%
  count() %>%
  arrange(desc(n))

aut_num <- filter(aut_group, n > 1)

aut_tidy_join <- left_join(aut_tidy, aut_group, by = "author") %>%
  group_by(L2) %>%
  arrange(desc(n), .by_group = TRUE) 

pkg_nodes <- aggregate(author ~ L2, aut_tidy_join, FUN = toString) %>%
  mutate(note = case_when(str_detect(author, "Ulrike") ~ "Groemping",
                          str_detect(L2, "Dice") ~ "Dupuy, Roustant, Richet, Deville",
                          str_detect(author, "Gramacy") ~ "Gramacy, Taddy",
                          str_detect(author, "Shwetank") ~ "Lall, Vhargese",
                          str_detect(author, "Kevin Wright") ~ "Wright",
                          str_detect(author, "Peng Liu") ~ "Liu",
                          str_detect(author, "Ernesto") ~ "Barrios")) %>%
  mutate(note = ifelse(is.na(note), "Other", note)) %>%
  mutate(name_add = case_when(L2 == "plgp" ~ "plgp (G)",
                              L2 == "tgp" ~ "tgp (G,T)",
                              L2 == "dynaTree" ~ "dynaTree (G,T)",
                              L2 == "DiceDesign" ~ "DiceDesign (Du,Ro)",
                              L2 == "DiceEval" ~ "DiceEval (Du)",
                              L2 == "DiceKriging" ~ "DiceKriging (Ro;De;Ri)",
                              L2 == "DiceView" ~ "DiceView (De;Ri)")) %>%
  mutate(name_add = ifelse(is.na(name_add), L2, name_add))

# # get first author 
# pkg_nodes_tmp$author <- rm_angle(pkg_nodes_tmp$author, replacement = "")
# pkg_nodes_tmp$author <- rm_square(pkg_nodes_tmp$author, replacement = "")
# pkg_nodes_tmp$author <- rm_white_punctuation(pkg_nodes_tmp$author, replacement = "")
# pkg_nodes_tmp$author <- ifelse(str_detect(pkg_nodes_tmp$author, "based"), "Ernesto Barrios", pkg_nodes_tmp$author)
# 
# pkg_nodes_tmp <- pkg_nodes_tmp %>%
#   cSplit("author", sep = " ,") %>%
#   select(c(1:2)) %>%
#   rename(first_aut = author_1) 
# 
# aut_gr <- pkg_nodes_tmp %>%
#   group_by(first_aut) %>%
#   count() %>%
#   ungroup() %>%
#   arrange(desc(n)) %>%
#   right_join(pkg_nodes_tmp, by = "first_aut")
# 
# 
# pkg_nodes <- aut_gr %>%
#   mutate(first_author = case_when(
#                                  n == 1 ~ "Other")) %>%
#   mutate(first_author = factor(first_author, levels = c("Ulrike Groemping",
#                                                         "John Lawson",
#                                                         "Robert B. Gramacy",
#                                                         "Ernesto Barrios",
#                                                         "Kevin Wright",
#                                                         "Shwetank Lall",
#                                                         "Other"))) %>%
#   select(L2, first_author)

# create igraph object
routes_igraph <- graph_from_data_frame(d = pkg_edges, vertices = pkg_nodes, directed = TRUE)

# create the input based on the igraph object
routes_tidy <- routes_igraph %>% as_tbl_graph() %>%
  activate(edges)

# create the nodes for interactive network
nodes <- pkg_nodes %>%
  rowid_to_column("id") %>%
  rename(label = name_add) %>%
  mutate(font.size = 25)

#create edges for interactive network
edges <-routes_tidy %>%
  activate(edges) %>%
  data.frame()

edges$color <- case_when(edges$type == "imports" ~ "green",
                         edges$type == "depends" ~ "red",
                         edges$type == "suggests" ~ "blue")

ledges <- data.frame(color = c("green", "red", "blue"), 
                     label = c("imports", "depends", "suggests")) 

```


```{r}
# interaction in survey CRAN task view

list_pkg_survey <- ctv:::.get_pkgs_from_ctv_or_repos("OfficialStatistics", 
                                                repos = "http://cran.rstudio.com/")[[1]]
url <- "http://cran.rstudio.com/web/packages/packages.rds"
db <- readRDS(url(url)) %>% 
  as.data.frame()
survey_pkg <- db %>%
  filter(Package %in% list_pkg_survey) %>%
  select(Package, Depends, Imports, Suggests)

get_pkg_survey <- function(var){
  # select only the package name and depends/imports/suggests
  tmp_df <- survey_pkg %>%
    select(Package, var) %>%
    # separate every depends/imports/suggests
    cSplit(var, sep = " ,") 
  
  df <- tmp_df %>%
    pivot_longer(c(2:ncol(tmp_df)), names_to = "type", values_to = "pkg") %>%
    filter(!is.na(pkg)) %>%
    # check if the depends/imports/suggests is also a DoE package (is in list_pkg)
    mutate(survey_pkg_related = ifelse(pkg %in% list_pkg_survey, "yes", "no")) %>%
    # filter only package whose depends/imports/suggests is a DoE
    filter(survey_pkg_related == "yes") %>%
    # tidy the data to only have the type: depends/imports/suggests
    cSplit("type", sep = "_") %>%
    select(-type_2) %>%
    rename(type = type_1)

  return(df)
}

survey_depends <- get_pkg_survey("Depends")
survey_imports <- get_pkg_survey("Imports")
survey_suggests <- get_pkg_survey("Suggests")

pkg_edges_survey <- rbind(survey_depends, survey_imports, survey_suggests)

survey_from <- pkg_edges_survey %>%
  distinct(Package)

# extract unique package that being depends/imports/suggests
survey_to <- pkg_edges_survey %>%
  distinct(pkg)

# create nodes from the two previous dataframe
pkg_nodes_survey <- full_join(survey_from, survey_to, by = c("Package" = "pkg"))


# Interaction in Time Series Analysis CRAN task view

list_pkg_ts <- ctv:::.get_pkgs_from_ctv_or_repos("TimeSeries", 
                                                repos = "http://cran.rstudio.com/")[[1]]

ts_pkg <- db %>%
  filter(Package %in% list_pkg_ts) %>%
  select(Package, Depends, Imports, Suggests)

get_pkg_ts <- function(var){
  # select only the package name and depends/imports/suggests
  tmp_df <- ts_pkg %>%
    select(Package, var) %>%
    # separate every depends/imports/suggests
    cSplit(var, sep = " ,") 
  
  df <- tmp_df %>%
    pivot_longer(c(2:ncol(tmp_df)), names_to = "type", values_to = "pkg") %>%
    filter(!is.na(pkg)) %>%
    # check if the depends/imports/suggests is also a DoE package (is in list_pkg)
    mutate(survey_pkg_related = ifelse(pkg %in% list_pkg_ts, "yes", "no")) %>%
    # filter only package whose depends/imports/suggests is a DoE
    filter(survey_pkg_related == "yes") %>%
    # tidy the data to only have the type: depends/imports/suggests
    cSplit("type", sep = "_") %>%
    select(-type_2) %>%
    rename(type = type_1)

  return(df)
}

ts_depends <- get_pkg_ts("Depends")
ts_imports <- get_pkg_ts("Imports")
ts_suggests <- get_pkg_ts("Suggests")

pkg_edges_ts <- rbind(ts_depends, ts_imports, ts_suggests)

ts_from <- pkg_edges_ts %>%
  distinct(Package)

# extract unique package that being depends/imports/suggests
ts_to <- pkg_edges_ts %>%
  distinct(pkg)

# create nodes from the two previous dataframe
pkg_nodes_ts <- full_join(ts_from, ts_to, by = c("Package" = "pkg"))
```




Interaction between packages could indicate of how developers utilize the functionality of one or more packages to create new features in their packages. According to @StanstrupJan2019TmTi, dependency and connectivity in terms of reusing codes and inheriting objects could reflect a well-connected and interacting community. In this paper, we observe the interaction limited to only between packages that are listed as DoE packages. Further, the type of interaction include the depended, imported, and suggested packages. Out of `r nrow(pkg_tidy)`, there are only `r nrow(pkg_nodes)` (`r round(nrow(pkg_nodes)/nrow(pkg_tidy)*100,2)`%) packages that interplay each other. This number is relatively lower compared to the percentage of interaction in the packages in Survey and Time Series Analysis CRAN Task View. We found that `r round(nrow(pkg_nodes_survey)/nrow(survey_pkg)*100,2)`% Survey packages that depends, imports, and suggests each other, while these interconnection is observed in `r round(nrow(nrow(pkg_nodes_ts)/nrow(ts_pkg)*100,2)`% Time Series Analysis packages. 

Further, we observe the interaction in DoE package using network visualisation using `igraph` [@igraph], `tidygraph` [@tidygraph], and `ggraph` [@ggraph]. 


```{r network-graph, fig.cap = "Interaction network between DoE R packages. The color of edges reflect the type of interaction, i.e., depends, imports, and suggests. Nodes' color indicates the authors who wrote more than 2 DoE packages.", fig.width=12, fig.height = 8}

# create the graph
ggraph(routes_tidy, layout = "kk") + 
  geom_edge_link(aes(color = type),
                 arrow = arrow(length = unit(2, 'mm')), 
                 end_cap = circle(2, 'mm')) + 
  geom_node_point(aes(color = note), size = 4) + 
  geom_node_text(aes(label = name_add), repel = TRUE, size = 3.1) +
  scale_color_manual(values = c("blue", "tomato", "magenta", "#48C9B0", "#C0392B", "#F1C40F", "grey50", "green")) +
  theme_graph() 
```


```{r, fig.width=12, fig.height = 7, fig.cap= "Package network based on authors who created more than 2 DoE packages. Packages authored by the same person tend to interplay each other."}

pkg_nodes_facet <- pkg_nodes %>%
  filter(note != "Other") 

pkg_edges_facet <- pkg_edges %>%
  filter(L2 %in% pkg_nodes_facet$L2 &
           pkg %in% pkg_nodes_facet$L2)



routes_igraph_facet <- graph_from_data_frame(d = pkg_edges_facet, 
                                             vertices = pkg_nodes_facet, 
                                             directed = TRUE)
 
# # create the input based on the igraph object
routes_tidy_facet <- routes_igraph_facet %>% as_tbl_graph() %>%
  activate(edges)

ggraph(routes_tidy_facet, layout = "stress") + 
  geom_edge_link(aes(color = type),
                 arrow = arrow(length = unit(3, 'mm')), 
                 end_cap = circle(3, 'mm')) + 
  geom_node_point(aes(color = note), size = 4) +
  geom_node_text(aes(label = name_add), repel = TRUE, size = 3.5) +
  theme_graph() +
  facet_nodes(~note) +
  scale_color_manual(values = c("blue", "tomato", "magenta", "#48C9B0", 
                                  "#C0392B", "#F1C40F", "green"), 
                     guide = "none") +
  th_foreground(foreground = "grey80",  border = TRUE) 
```


Figure \@ref(fig:network-graph) shows the interplay of DoE packages.  The most downloaded DoE packages, such as `AlgDesign`, `rsm`, and `lhs` are observed to support many other packages. Dependent packages seems to use their functions to support their feature. We also observe that  `DoE.base` and `FrF2`, which are created by the same author, Ulrike Groemping, are also imported, depended, and suggested by many other packages because of their basic functionality in experimental design. Moreover, some of interacting packages, such as `DoE.wrapper` and `DoE.MIParray` are also developed by Groemping. Further, packages regarding computer experiment (`DiceKriging`, `DiceEval`, `DiceView`, and `DiceDesign`) happen to interplay with each other so that they appear to form a sub-cluster. These packages also written by authors that interplay each other. 

The four smaller clusters interact because of the similarity in their type and domain. For example `dfcm` and `dfpk` are used for dose-finding experiments. Regarding the similarity of its objective, although `FMC` aims to generate factorial design, this package does not interact with the packages in the big cluster, even though some packages in this cluster, such as `DoE.base`, also involve factorial design. This package instead imports `minimalRSD`, which is developed by the same author. This is also observed in the smaller network involves `dynaTree`, `plgp`, and `tgp`. These three interplaying package are authored by the same author as well.

Based on this network, we can say that the interconnection of DoE package is due to functionality dependence, similarity of type or domain, and because they are developed by the same author/s. 

```{r int-plot}
visNetwork(nodes, edges, height = "500px", width = "100%") %>%
  visOptions(selectedBy = "note") %>%
  visLayout(randomSeed = 123) %>%
  visEdges(shadow = FALSE,
           arrows =list(to = list(enabled = TRUE, scaleFactor = 2))) %>%
  visLegend(useGroups = F, addEdges = ledges)
```




